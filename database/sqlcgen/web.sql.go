// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: web.sql

package sqlcgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countObjectsForWeb = `-- name: CountObjectsForWeb :one
SELECT COUNT(*) as total
FROM Objects
WHERE deleted_at IS NULL
  AND ($1::text = '' OR object_type = $1)
  AND ($2::text = '' OR distinguishedName ILIKE '%' || $2 || '%')
`

type CountObjectsForWebParams struct {
	Column1 string `json:"column_1"`
	Column2 string `json:"column_2"`
}

func (q *Queries) CountObjectsForWeb(ctx context.Context, arg CountObjectsForWebParams) (int64, error) {
	row := q.db.QueryRow(ctx, countObjectsForWeb, arg.Column1, arg.Column2)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const getObjectByID = `-- name: GetObjectByID :one
SELECT object_id, object_type, distinguishedName, updated_at, deleted_at
FROM Objects
WHERE object_id = $1
`

type GetObjectByIDRow struct {
	ObjectID          pgtype.UUID      `json:"object_id"`
	ObjectType        string           `json:"object_type"`
	Distinguishedname string           `json:"distinguishedname"`
	UpdatedAt         pgtype.Timestamp `json:"updated_at"`
	DeletedAt         pgtype.Timestamp `json:"deleted_at"`
}

func (q *Queries) GetObjectByID(ctx context.Context, objectID pgtype.UUID) (GetObjectByIDRow, error) {
	row := q.db.QueryRow(ctx, getObjectByID, objectID)
	var i GetObjectByIDRow
	err := row.Scan(
		&i.ObjectID,
		&i.ObjectType,
		&i.Distinguishedname,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getObjectTimeline = `-- name: GetObjectTimeline :many
SELECT usn_changed, timestamp, attributes_snapshot, modified_by
FROM ObjectVersions
WHERE object_id = $1
ORDER BY usn_changed DESC
`

type GetObjectTimelineRow struct {
	UsnChanged         int64            `json:"usn_changed"`
	Timestamp          pgtype.Timestamp `json:"timestamp"`
	AttributesSnapshot []byte           `json:"attributes_snapshot"`
	ModifiedBy         pgtype.Text      `json:"modified_by"`
}

func (q *Queries) GetObjectTimeline(ctx context.Context, objectID pgtype.UUID) ([]GetObjectTimelineRow, error) {
	rows, err := q.db.Query(ctx, getObjectTimeline, objectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetObjectTimelineRow
	for rows.Next() {
		var i GetObjectTimelineRow
		if err := rows.Scan(
			&i.UsnChanged,
			&i.Timestamp,
			&i.AttributesSnapshot,
			&i.ModifiedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getObjectTypes = `-- name: GetObjectTypes :many
SELECT DISTINCT object_type
FROM Objects
WHERE deleted_at IS NULL
ORDER BY object_type
`

func (q *Queries) GetObjectTypes(ctx context.Context) ([]string, error) {
	rows, err := q.db.Query(ctx, getObjectTypes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var object_type string
		if err := rows.Scan(&object_type); err != nil {
			return nil, err
		}
		items = append(items, object_type)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVersionChanges = `-- name: GetVersionChanges :many
SELECT ac.attribute_schema_id, s.ldap_display_name, ac.old_value, ac.new_value, ac.timestamp, s.is_single_valued
FROM AttributeChanges ac
JOIN AttributeSchemas s ON ac.attribute_schema_id = s.object_guid
WHERE ac.object_id = $1 AND ac.usn_changed = $2
ORDER BY s.ldap_display_name
`

type GetVersionChangesParams struct {
	ObjectID   pgtype.UUID `json:"object_id"`
	UsnChanged int64       `json:"usn_changed"`
}

type GetVersionChangesRow struct {
	AttributeSchemaID pgtype.UUID      `json:"attribute_schema_id"`
	LdapDisplayName   string           `json:"ldap_display_name"`
	OldValue          []byte           `json:"old_value"`
	NewValue          []byte           `json:"new_value"`
	Timestamp         pgtype.Timestamp `json:"timestamp"`
	IsSingleValued    bool             `json:"is_single_valued"`
}

func (q *Queries) GetVersionChanges(ctx context.Context, arg GetVersionChangesParams) ([]GetVersionChangesRow, error) {
	rows, err := q.db.Query(ctx, getVersionChanges, arg.ObjectID, arg.UsnChanged)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetVersionChangesRow
	for rows.Next() {
		var i GetVersionChangesRow
		if err := rows.Scan(
			&i.AttributeSchemaID,
			&i.LdapDisplayName,
			&i.OldValue,
			&i.NewValue,
			&i.Timestamp,
			&i.IsSingleValued,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listObjectsForWeb = `-- name: ListObjectsForWeb :many
SELECT object_id, object_type, distinguishedName, updated_at, deleted_at
FROM Objects
WHERE deleted_at IS NULL
  AND ($1::text = '' OR object_type = $1)
  AND ($2::text = '' OR distinguishedName ILIKE '%' || $2 || '%')
ORDER BY updated_at DESC
LIMIT $3 OFFSET $4
`

type ListObjectsForWebParams struct {
	Column1 string `json:"column_1"`
	Column2 string `json:"column_2"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type ListObjectsForWebRow struct {
	ObjectID          pgtype.UUID      `json:"object_id"`
	ObjectType        string           `json:"object_type"`
	Distinguishedname string           `json:"distinguishedname"`
	UpdatedAt         pgtype.Timestamp `json:"updated_at"`
	DeletedAt         pgtype.Timestamp `json:"deleted_at"`
}

func (q *Queries) ListObjectsForWeb(ctx context.Context, arg ListObjectsForWebParams) ([]ListObjectsForWebRow, error) {
	rows, err := q.db.Query(ctx, listObjectsForWeb,
		arg.Column1,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListObjectsForWebRow
	for rows.Next() {
		var i ListObjectsForWebRow
		if err := rows.Scan(
			&i.ObjectID,
			&i.ObjectType,
			&i.Distinguishedname,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
